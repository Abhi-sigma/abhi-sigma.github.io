<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto-Spawn Targets Example</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #uiPanel {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: #ffffffcc;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 18px;
            font-family: sans-serif;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        #captureUI {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            font-family: sans-serif;
            font-size: 16px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            max-width: 180px;
        }

        li {
            list-style: none;
            margin: 2px 0;
            padding: 2px 5px;
            background: #f0f0f0;
            border-radius: 4px;
            font-size: 14px;
        }
        #levelUI {
  position: absolute;
  top: 0;
  width: 100%;
  background: rgba(0, 0, 0, 0.6);
  color: white;
  font-family: sans-serif;
  text-align: center;
  padding: 10px;
  z-index: 100;
  pointer-events: none;
}

#levelTargets {
  margin-top: 5px;
  display: flex;
  justify-content: center;
  gap: 10px;
}

.target-num {
  padding: 5px 10px;
  border: 2px solid white;
  border-radius: 5px;
  font-weight: bold;
}

.target-num.captured {
  background-color: green;
  border-color: green;
  color: white;
  position: relative;
}

.target-num.captured::after {
  content: 'âœ”';
  position: absolute;
  top: -8px;
  right: -8px;
  background: #2e7d32;
  border-radius: 50%;
  font-size: 12px;
  padding: 2px 5px;
}

    </style>
</head>

<body>
    
    
    <div id="captureUI">
        <div><strong>Captured Blocks:</strong></div>
        <ul id="captureList" style="padding-left: 20px; margin: 5px 0;"></ul>
        <div><strong>Total:</strong> <span id="totalValue">0</span></div>
    </div>
    <div id="levelUI">
  <div id="levelMessage">Capture <span id="currentTargetDisplay">---</span></div>
  <div id="levelTargets"></div>
</div>


    <script>
        const config = {
            type: Phaser.AUTO,
            width: window.innerWidth,
            height: window.innerHeight,
            physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: true } },
            scene: { preload, create, update }
        };


        const game = new Phaser.Game(config);
        let currentTargetIndex = 0;
        let currentLevel = 1;
        let currentTarget = 0;
        let targetParts = [];
        let capturedParts = { };
        let toCaptureParts = {};
        let capturedBlocks = [];
        let captureTray = [];
        let targets = [];
        let totalCaptured = 0;
        let levels = {
            1: generateRandomNumbers(2, 1, 9),
            2: [20,40],  //generateRandomNumbers(1, 100, 999),
            3: generateRandomNumbers(1, 1000, 9999),
            4: generateRandomNumbers(1, 10000, 99999),
            5: generateRandomNumbers(1, 100000, 999999),
            6: generateRandomNumbers(1, 1000000, 1000000),
        };
        const placeValues = [1, 100, 1000, 10000, 100000, 1000000];


        function preload() {
            // this.load.image('skyBg', 'https://cdn.pixabay.com/photo/2015/09/18/19/03/sky-95720_1280.jpg');
        }

        function generateRandomNumbers(count, min, max) {
            const nums = [];
            for (let i = 0; i < count; i++) {
               const rand = Math.floor(Math.random() * (max - min + 1)) + min;
               if (nums.includes(rand)) {
                    i--; // Ensure unique numbers
                } 
                else if  (rand >= min && rand <= max ) {
                nums.push(rand);
            }
        }
        
            return nums;
        }


        function showLevelTargets(levelNumbers, currentTarget) {
            console.log("showLevelTargets", levelNumbers, currentTarget,currentLevel);
                const container = document.getElementById("levelTargets");
                const display = document.getElementById("currentTargetDisplay");
                display.textContent = currentTarget;
                container.innerHTML = '';
                levelNumbers.forEach(num => {
                    const span = document.createElement('span');
                    span.classList.add('target-num');
                    span.textContent = num;
                    span.dataset.value = num;
                    container.appendChild(span);
                });
            }
            function markTargetCapturedUI(value) {
                    const targetEl = document.querySelector(`.target-num[data-value="${value}"]`);
                    if (targetEl) {
                        targetEl.classList.add("captured");
                    }
                    else{
                        console.warn(`Element target-${index} not found`);
                    }
                }

        function create() {
            const worldWidth = 3000;
            const worldHeight = 2000;
            const groundHeight = 1400;

            this.cameras.main.setBounds(0, 0, worldWidth, worldHeight);
            this.physics.world.setBounds(0, 0, worldWidth, worldHeight);

            // Draw grass
            const grass = this.add.graphics();
            grass.fillStyle(0x228B22, 1);
            grass.fillRect(0, worldHeight - groundHeight, worldWidth, groundHeight);

            // Create player sprite
            const g = this.add.graphics();
            g.fillStyle(0x0000ff, 1);
            g.fillRect(0, 0, 40, 40);
            g.generateTexture('playerBlock', 40, 40);

            player = this.physics.add.sprite(worldWidth / 2, worldHeight / 2, 'playerBlock').setCollideWorldBounds(true);
            this.cameras.main.startFollow(player);

            cursors = this.input.keyboard.createCursorKeys();

            obstacles = this.physics.add.staticGroup();
            targets = this.physics.add.group();  // clear + ensure physics group

            // Place rocks
            for (let i = 0; i < 30; i++) {
                const x = Phaser.Math.Between(100, worldWidth - 100);
                const y = Phaser.Math.Between(100, worldHeight - 100);
                const rock = this.add.rectangle(x, y, 60, 60, 0x888888);
                this.physics.add.existing(rock, true);
                obstacles.add(rock);
            }

            this.physics.add.collider(player, obstacles);
            
            // ðŸ‘‡ Generate level blocks for current level & index
            generateTargetBlocks(levels[currentLevel][currentTargetIndex], this);
            

            // ðŸ‘‡ Setup minimap
            this.minimap = this.cameras.add(10, 10, 200, 200)
                .setZoom(0.07)
                .setName('mini')
                .setBackgroundColor(0x002244);

            this.minimap.startFollow(player);
            this.minimap.ignore(obstacles);

            // âœ… Overlap for capture
            this.physics.add.overlap(player, targets, (player, block) => {
                captureBlock(this, block);
            }, null, this);

            // ðŸ‘‡ Auto re-activate blocks
            this.time.addEvent({
                delay: 3000,
                loop: true,
                callback: () => {
                    targets.getChildren().forEach(t => {
                        if (t.body && t.body.velocity.length() < 10) {
                            const angle = Phaser.Math.FloatBetween(0, 2 * Math.PI);
                            t.body.setVelocity(Math.cos(angle) * 100, Math.sin(angle) * 100);
                        }
                    });
                }
            });
        }

        function spawnTargets(scene) {
            const cam = scene.cameras.main;
            const padding = 50;

            const x = Phaser.Math.Between(cam.scrollX + padding, cam.scrollX + cam.width - padding);
            const y = Phaser.Math.Between(cam.scrollY + padding, cam.scrollY + cam.height - padding);

            const g = scene.add.graphics();
            g.fillStyle(0xffaa00, 1);
            g.fillRect(0, 0, 40, 40);
            const texKey = "target" + Phaser.Math.Between(0, 9999);
            g.generateTexture(texKey, 40, 40);

            const target = scene.physics.add.sprite(x, y, texKey);
            target.setBounce(1, 1);
            target.setCollideWorldBounds(true);
            target.body.setVelocity(Phaser.Math.Between(-100, 100), Phaser.Math.Between(-100, 100));

            targets.add(target);
        }

        function captureBlock(scene, block) {
            if (!block.body) return;

            if (block.body) {
                block.body.enable = false;
                block.body.stop();
            }


            const value = block.getData('value');
            if (value) {
                capturedBlocks.push(value);
                totalCaptured += value;
                capturedParts[value] = (capturedParts[value] || 0) + 1;
                
                checkTargetComplete(scene)
                updateCaptureUI();
            }

            targets.remove(block, true, false); // âœ… Don't destroy immediately
            // âœ… Disable physics and hide

            const trayX = scene.cameras.main.scrollX + 60 + (capturedBlocks.length - 1) * 45;
            const trayY = scene.cameras.main.scrollY + 60;

            block.setDepth(10);
            block.setVisible(false);
            block.setActive(true);
            if (block.body) {
                block.body.enable = false;
            }
            scene.tweens.add({
                targets: block,
                x: trayX,
                y: trayY,
                alpha: 1,
                duration: 500,
                onStart: () => {
                    block.setVisible(true);
                    block.setActive(true);
                },
                onComplete: () => {
                    captureTray.push(block);
                }
            });

            // Optional sound/animation can be added here
        }

        function updateCaptureUI() {
            const list = document.getElementById('captureList');
            const total = document.getElementById('totalValue');

            list.innerHTML = capturedBlocks.map(v => `<li>${v}</li>`).join('');
            total.textContent = totalCaptured;
        }



        function checkTargetComplete(scene) {
                let remaining = currentTarget;
                let isComplete = false;

              const checkTargets = (capturedParts, toCaptureParts) => {
                const keys1 = Object.keys(capturedParts);
                const keys2 = Object.keys(toCaptureParts);
                if (keys1.length !== keys2.length) return false;

                for (let key of keys1) {
                    if (capturedParts[key] !== toCaptureParts[key]) return false;
                }
                return true;
            };
            
            if (checkTargets(capturedParts, toCaptureParts)) {
                isComplete = true;
                currentTargetIndex++;
            }
            else {
                isComplete = false;

            }

                if (isComplete) {
                    // alert("Target completed! Advancing to next number.");
                    

                    // Clear visuals and counters
                    captureTray.forEach(block => block.destroy());
                    captureTray = [];
                    capturedBlocks = [];
                    totalCaptured = 0;

                    // Next target
                    let next = levels[currentLevel][currentTargetIndex];
                    if (next) {
                        toCaptureParts = {};
                        capturedParts = {};
                        
                        generateTargetBlocks(next, game.scene.scenes[0]);
                    } else {
                        alert("Level complete!");
                        currentLevel++;
                        currentTargetIndex = 0;
                        if (levels[currentLevel]) {
                            toCaptureParts = {};
                            capturedParts = {};
                            currentTargetIndex = 0
                            generateTargetBlocks(levels[currentLevel][currentTargetIndex], game.scene.scenes[0]);
                        } else {
                            alert("All levels done!");
                        }
                    }
                }
            }



        function update() {
            let atEdge = false;
            player.setVelocity(0);

            if (cursors.left.isDown) player.setVelocityX(-200);
            if (cursors.right.isDown) player.setVelocityX(200);
            if (cursors.up.isDown) player.setVelocityY(-200);
            if (cursors.down.isDown) player.setVelocityY(200);


            targets.children.iterate(block => {
                if (!block.body) return;

                const dx = block.x - player.x;
                const dy = block.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 150) {
                    const vx = (dx / dist) * 100;
                    const vy = (dy / dist) * 100;
                    block.body.setVelocity(vx, vy);
                }

                // LEFT edge
                if (block.x <= 0) {
                    atEdge = true;
                    block.x = 1;
                    block.body.setVelocityX(Math.abs(block.body.velocity.x));
                }

                // RIGHT edge
                if (block.x >= config.width - 40) {
                    atEdge = true;
                    block.x = config.width - 41;
                    block.body.setVelocityX(-Math.abs(block.body.velocity.x));
                }

                // TOP edge
                if (block.y <= 0) {
                    atEdge = true;
                    block.y = 1;
                    block.body.setVelocityY(Math.abs(block.body.velocity.y));
                }

                // BOTTOM edge
                if (block.y >= config.height - 40) {
                    atEdge = true;
                    block.y = config.height - 41;
                    block.body.setVelocityY(-Math.abs(block.body.velocity.y));
                }
                const distance = Phaser.Math.Distance.Between(player.x, player.y, block.x, block.y);

                if (distance < 100 && !atEdge) { // chase range
                    // Random scatter direction (not directly opposite, adds variation)
                    const angle = Phaser.Math.Angle.Between(player.x, player.y, block.x, block.y) + Phaser.Math.FloatBetween(-0.5, 0.5);
                    const speed = Phaser.Math.Between(150, 250);
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    block.body.setVelocity(vx, vy);
                }


            });
        }
        function generateTargetBlocks(number, scene) {
            showLevelTargets(levels[currentLevel], levels[currentLevel][currentTargetIndex]);
            currentTarget = number;
            if(levels[currentLevel][currentTargetIndex-1] !== undefined) {
                markTargetCapturedUI(levels[currentLevel][currentTargetIndex-1]);
            }
        
            targetParts = [];

            // Break number into place values (e.g., 1234 => [1000, 200, 30, 4])
            const digits = number.toString().split('').map(Number);
            const numDigits = digits.length;

            
            let valueParts = [];
            for (let i = 0; i < numDigits; i++) {
                const placeValue = Math.pow(10, numDigits - i - 1);
                const digit = digits[i];

                if (digit > 0) {
               toCaptureParts [placeValue] = digit;
                    for (let j = 0; j < digit; j++) {
                        valueParts.push(placeValue);
                    }
                }
            }

            // Spawn blocks for each value part
            valueParts.forEach(value => {
                const count = value / getPlaceValue(value); // e.g., 300 => spawn 3 x 100
                spawnBlockParts(scene, count, getPlaceValue(value));
            });

            // UI updates
        //     document.getElementById('targetNum').textContent = currentTarget;

        //     const uiPanel = document.getElementById('uiPanel');
            
        //     uiPanel.innerHTML = `Target: <span id="targetNum">${currentTarget}</span> | ` +
        //         valueParts.map(v => {
        //             return `${getPlaceValue(v)}s: <span id="${getPlaceValue(v)}Count">0</span> / ${v / getPlaceValue(v)}`;
        //         }).join(', ');
        }
        function getPlaceValue(value) {
            if (value === 0) return 1;
            return Math.pow(10, Math.floor(Math.log10(value)));
        }


        function spawnBlockParts(scene, count, value) {
            const cam = scene.cameras.main;
            const padding = 40;
            const spacing = 60;
            let blocksSpawned = 0;

            const attemptSpawn = () => {
                if (blocksSpawned >= count) return;

                let attempts = 0;
                let placed = false;

                while (!placed && attempts < 30) {
                    const x = Phaser.Math.Clamp(
                        Phaser.Math.Between(cam.scrollX + padding, cam.scrollX + cam.width - padding),
                        padding, scene.physics.world.bounds.width - padding
                    );
                    const y = Phaser.Math.Clamp(
                        Phaser.Math.Between(cam.scrollY + padding, cam.scrollY + cam.height - padding),
                        padding, scene.physics.world.bounds.height - padding
                    );

                    let tooClose = targets.getChildren().some(p =>
                        Phaser.Math.Distance.Between(p.x, p.y, x, y) < spacing
                    );

                    if (!tooClose) {
                        const color = value === 10 ? 0xffaa00 : 0xaaff00;
                        const block = scene.add.rectangle(0, 0, 40, 40, color).setStrokeStyle(1, 0x000000);
                        const label = scene.add.text(0, 0, value.toString(), { fontSize: '18px', color: '#000' }).setOrigin(0.5);
                        const container = scene.add.container(x, y, [block, label]);
                        container.setData('value', value);

                        scene.physics.add.existing(container); // âœ… Add physics
                        container.body.setCollideWorldBounds(true);
                        container.body.setBounce(1, 1);
                        container.body.setVelocity(
                            Phaser.Math.Between(-100, 100),
                            Phaser.Math.Between(-100, 100)
                        );

                        targets.add(container); // âœ… Add to targets group
                        targetParts.push(container);
                        placed = true;
                        blocksSpawned++;
                    }

                    attempts++;
                }

                if (!placed) {
                    console.warn(`Could not place block of value ${value} after 30 attempts`);
                }

                if (blocksSpawned < count) {
                    scene.time.delayedCall(200, attemptSpawn, null, scene);
                }
            };

            attemptSpawn();
        }


    </script>

</body>

</html>