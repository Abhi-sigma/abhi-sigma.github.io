<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Times Table Dots - Progressive Dots with Locking</title>
<style>
  body {
    margin: 0;
    display: flex;
    height: 100vh;
    overflow: hidden;
    font-family: 'Segoe UI', sans-serif;
    background: #f9f9f9;
}

#sidePanel {
    width: 260px;
    background: #ffffff;
    border-right: 1px solid #ddd;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    box-sizing: border-box;
    padding: 20px;
    box-shadow: 2px 0 8px rgba(0, 0, 0, 0.05);
}

#progressLog {
    text-align: center;
    font-size: 22px;
    line-height: 1.6;
    max-height: 60vh;
    overflow-y: auto;
    width: 100%;
    color: #333;
}

#sidePanel h3 {
    font-size: 26px;
    margin-bottom: 20px;
    color: #0077cc;
}

button {
    width: 100%;
    padding: 12px 16px;
    margin-top: 20px;
    font-size: 18px;
    border: none;
    background: #0077cc;
    color: white;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.3s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

button:hover {
    background: #005fa3;
}
/* Default large size in play area */
.big-circle {
    width: 120px;
    height: 120px;
}

.dot {
    width: 30px;
    height: 30px;
}

/* Inside container, smaller circles and dots */
#bigCircleContainer .big-circle {
    width: 60px;
    height: 60px;
}

#bigCircleContainer .dot {
    width: 10px;
    height: 10px;
}

#playArea {
    flex-grow: 1;
    position: relative;
    background: #e8f6fb;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

#bigCircleContainer {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    padding: 10px;
    background: #d0ecfa;
    justify-content: flex-start;
    z-index: 1;
    min-height: 140px;
    position: relative;
    border-bottom: 1px solid #ccc;
}

#gameAreaInner {
    flex-grow: 1;
    position: relative;
    overflow: hidden;
}

.dot {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    background: #ff7b7b;
    position: absolute;
    cursor: grab;
    border: 2px solid #333;
    transition: left 0.4s ease, top 0.4s ease, transform 0.2s ease;
    z-index: 2;
    touch-action: none;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.dot:hover {
    transform: scale(1.1);
}

.dot.placed {
    background: #66d28c;
    cursor: default;
}

.big-circle-wrapper {
    position: relative;
    transition: left 0.7s ease, top 0.7s ease;
}

.big-circle {
    width: 200px;
    height: 200px;
    border-radius: 50%;
    background: #a0d6ff;
    border: 4px solid #0077cc;
    position: relative;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
}
#floatingMessage {
    position: absolute;
    top: 20%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 119, 204, 0.9);
    color: white;
    font-size: 28px;
    padding: 12px 20px;
    border-radius: 8px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease;
    z-index: 10;
}

@media (max-width: 768px) {
    body {
        flex-direction: column;
    }

    #sidePanel {
        width: 100%;
        height: auto;
        border-right: none;
        border-bottom: 1px solid #ccc;
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        align-items: center;
        padding: 10px;
        z-index: 2;
        background: #fff;
    }

    #playArea {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
    }
    .big-circle-wrapper {
    position: relative;
    transition: left 0.7s ease, top 0.7s ease;
}
}

@media (max-width: 320px) {
    .dot {
        width: 40px;
        height: 40px;
    }
}
#sidePanel {
    width: 260px;
    background: #fff;
    border-right: 1px solid #ddd;
    box-shadow: 2px 0 8px rgba(0, 0, 0, 0.05);
    position: fixed;
    top: 0;
    left: -260px; /* Hide off-screen initially */
    height: 100%;
    z-index: 100;
    transition: left 0.3s ease;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
}

#sidePanel.open {
    left: 0;
}

#toggleHandle {
    position: fixed;
    top: 100px;
    left: 0;
    width: 30px;
    height: 80px;
    background: #0077cc;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    cursor: pointer;
    z-index: 110;
    border-top-right-radius: 6px;
    border-bottom-right-radius: 6px;
    box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
    transition: background 0.3s ease;
}

#toggleHandle:hover {
    background: #005fa3;
}





 
</style>
</head>
<body>
<div id="floatingMessage"></div>
<div id="sidePanel">
    <div id="toggleHandle">≡</div>
  <h3>Progress</h3>
  <div id="progressLog"></div>
  <button id="resetBtn">Reset</button>
</div>

<div id="playArea">
  <div id="bigCircleContainer"></div>
  <div id="gameAreaInner"></div>
</div>

<script>
const playArea = document.getElementById('playArea');
const gameAreaInner = document.getElementById('gameAreaInner');
const bigCircleContainer = document.getElementById('bigCircleContainer');
const progressLog = document.getElementById('floatingMessage');
const progressLogHidden = document.getElementById('progressLog');
const sidePanel = document.getElementById('sidePanel');
const toggleHandle = document.getElementById('toggleHandle');
const dotRadius = 15;
const bigCircleRadius = 200;

toggleHandle.addEventListener('click', () => {
    sidePanel.classList.toggle('open');
});

const timesTable = 12;
const maxStep = 12;
const totalDots = timesTable * maxStep;
const visibleDots = 5;

let currentStep = 1;
let placedThisStep = 0;
let totalDotsRemaining = totalDots;

let dots = [];
let bigWrappers = [];
let dragging = null;
let offsetX = 0;
let offsetY = 0;

init();

function init() {
    dots = [];
    totalDotsRemaining = totalDots;
    placedThisStep = 0;
    bigWrappers = [];
    progressLog.innerHTML = '';
    currentStep = 1;

    generateBigCircle();
    generateDots(Math.min(visibleDots, totalDotsRemaining));
}

function generateDots(count) {
    const wrapper = bigWrappers[bigWrappers.length - 1];
    const circle = wrapper.querySelector('.big-circle');
    const wrapperRect = wrapper.getBoundingClientRect();
    const gameRect = gameAreaInner.getBoundingClientRect();

    const centerX = wrapperRect.left + circle.offsetWidth / 2 - gameRect.left;
    const centerY = wrapperRect.top + circle.offsetHeight / 2 - gameRect.top;
    const spawnRadius = 150; // Distance from center where dots will appear

    for (let i = 0; i < count; i++) {
        const angle = Math.random() * 2 * Math.PI;

        const x = centerX + spawnRadius * Math.cos(angle) - dotRadius;
        const y = centerY + spawnRadius * Math.sin(angle) - dotRadius;

        const dot = document.createElement('div');
        dot.classList.add('dot');
        dot.style.left = `${x}px`;
        dot.style.top = `${y}px`;

        gameAreaInner.appendChild(dot);
        dots.push(dot);

        dot.addEventListener('mousedown', (e) => {
            if (dot.classList.contains('placed')) return;
            dragging = dot;
            offsetX = e.offsetX;
            offsetY = e.offsetY;
        });

        dot.addEventListener('touchstart', (e) => {
            if (dot.classList.contains('placed')) return;
            const touch = e.touches[0];
            const rect = dot.getBoundingClientRect();
            dragging = dot;
            offsetX = touch.clientX - rect.left;
            offsetY = touch.clientY - rect.top;
        }, { passive: false });
    }

    totalDotsRemaining -= count;
}
function showFloatingMessage(text) {
    const msg = document.getElementById('floatingMessage');
    msg.innerText = text;
    msg.style.opacity = '1';

    setTimeout(() => {
        msg.style.opacity = '0';
    }, 2500); // Visible for 2.5 seconds
}

function generateBigCircle() {
    const wrapper = document.createElement('div');
    wrapper.classList.add('big-circle-wrapper');

    const centerX = (gameAreaInner.clientWidth - bigCircleRadius) / 2;
    const centerY = (gameAreaInner.clientHeight - bigCircleRadius) / 2;

    wrapper.style.left = `${centerX}px`;
    wrapper.style.top = `${centerY}px`;

    const circle = document.createElement('div');
    circle.classList.add('big-circle');
    wrapper.appendChild(circle);

    gameAreaInner.appendChild(wrapper);
    bigWrappers.push(wrapper);
}

document.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    const rect = gameAreaInner.getBoundingClientRect();
    dragging.style.left = (e.clientX - rect.left - offsetX) + 'px';
    dragging.style.top = (e.clientY - rect.top - offsetY) + 'px';
});

document.addEventListener('touchmove', (e) => {
    if (!dragging) return;
    const touch = e.touches[0];
    const rect = gameAreaInner.getBoundingClientRect();
    dragging.style.left = (touch.clientX - rect.left - offsetX) + 'px';
    dragging.style.top = (touch.clientY - rect.top - offsetY) + 'px';
}, { passive: false });

document.addEventListener('mouseup', handleDrop);
document.addEventListener('touchend', handleDrop);

function handleDrop() {
    if (!dragging) return;

    const wrapper = bigWrappers[bigWrappers.length - 1];
    const circle = wrapper.querySelector('.big-circle');

    if (isInBigCircle(dragging, circle)) {
        dragging.classList.add('placed');
        gameAreaInner.removeChild(dragging);
        circle.appendChild(dragging);

        const angle = (placedThisStep) * (2 * Math.PI / timesTable);
        const radius = 45;
        const center = bigCircleRadius/2; // Center of big circle
        const dotOffset = dotRadius/2; // Half dot size

        const x = center + radius * Math.cos(angle) - dotOffset;
        const y = center + radius * Math.sin(angle) - dotOffset;

        dragging.style.left = `${x}px`;
        dragging.style.top = `${y}px`;

        // Disable further dragging
        dragging.style.cursor = 'default';
        dragging.removeEventListener('mousedown', () => {});
        dragging.removeEventListener('touchstart', () => {});

        placedThisStep++;

        if (totalDotsRemaining > 0) {
            generateDots(1);
        }

        if (placedThisStep === timesTable) {
    const message = `${timesTable} x ${currentStep} = ${timesTable * currentStep}`;
    const speakMessage = `${timesTable} times ${currentStep} = ${timesTable * currentStep}`;
    logProgress(message);
    speak(speakMessage);
    showFloatingMessage(message);

    placedThisStep = 0;
    animateWrapperToContainer(wrapper);

    currentStep++;
    if (currentStep <= maxStep) {
        generateBigCircle();
    } else {
        logProgress(`✅ Table Complete!`);
        speak(`Well done, you finished the ${timesTable} times table.`);
    }
}
    }

    dragging = null;
}

function animateWrapperToContainer(wrapper) {
    const targetRect = bigCircleContainer.getBoundingClientRect();
    const wrapperRect = wrapper.getBoundingClientRect();

    const offsetX = targetRect.left - wrapperRect.left + 10;
    const offsetY = targetRect.top - wrapperRect.top + 10;

    wrapper.style.left = `${parseFloat(wrapper.style.left) + offsetX}px`;
    wrapper.style.top = `${parseFloat(wrapper.style.top) + offsetY}px`;

    setTimeout(() => {
    wrapper.style.position = 'relative';
    wrapper.style.left = '0';
    wrapper.style.top = '0';
    bigCircleContainer.appendChild(wrapper);

    // Reposition dots based on new, smaller size
    const circle = wrapper.querySelector('.big-circle');
    const placedDots = circle.querySelectorAll('.dot');
    const newCenter = circle.offsetWidth / 2;
    const newRadius = (circle.offsetWidth / 2) - parseFloat(getComputedStyle(placedDots[0]).width);

    placedDots.forEach((dot, index) => {
        const angle = index * (2 * Math.PI / timesTable);
        const dotSize = parseFloat(getComputedStyle(dot).width);

        const x = newCenter + newRadius * Math.cos(angle) - dotSize / 2-5;
        const y = newCenter + newRadius * Math.sin(angle) - dotSize / 2-5;

        dot.style.left = `${x}px`;
        dot.style.top = `${y}px`;
    });
}, 700);

}

function isInBigCircle(dot, big) {
    const b = big.getBoundingClientRect();
    const d = dot.getBoundingClientRect();
    const dx = (d.left + d.width / 2) - (b.left + b.width / 2);
    const dy = (d.top + d.height / 2) - (b.top + b.height / 2);
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < b.width / 2 - d.width / 2;
}

function logProgress(text) {
    const entry = document.createElement('div');
    entry.innerText = text;
    progressLogHidden.appendChild(entry);
    progressLogHidden.scrollTop = progressLog.scrollHeight;
}

function speak(text) {
    const msg = new SpeechSynthesisUtterance(text);
    speechSynthesis.speak(msg);
}

document.getElementById('resetBtn').addEventListener('click', () => {
    dots.forEach(d => {
        if (d.parentElement === gameAreaInner) gameAreaInner.removeChild(d);
    });
    bigWrappers.forEach(w => w.remove());
    dots = [];
    bigWrappers = [];
    progressLogHidden.innerHTML = '';
    currentStep = 1;
    placedThisStep = 0;
    totalDotsRemaining = totalDots;
    init();
});
</script>

</body>
</html>
